
;s5=serial.Serial(port="COM5",baudrate=800000,bytesize=serial.EIGHTBITS,parity=serial.PARITY_NONE,stopbits=serial.STOPBITS_TWO,timeout=None,xonxoff=False,rtscts=False,writeTimeout=None,dsrdtr=False,interCharTimeout=None)

; config:
; RX/TX on usual port B1/B2 (pins 7,8)
; LED data out: port A0 (pin 17)
; baud select jumper: port B4/B5 (pins 9,10)

;data format: 16-bit per pixel, bigendian, RGB 15, 1:5:5:5, 
; sent to stripe as high, mid, low. typically GRB, sometimes BRG


INDF0   = 0x000
INDF1   = 0x001
STATUS  = 0x003
FSR0L   = 0x004
FSR0H   = 0x005
FSR1L   = 0x006
FSR1H   = 0x007
BSR     = 0x008
WREG    = 0x009
PCLATH  = 0x00A
INTCON  = 0x00B
PORTA   = 0x00C
PORTB   = 0x00D
PIR1    = 0x011
TMR2    = 0x01A
PR2     = 0x01B
T2CON   = 0x01C
TRISA   = 0x08C
TRISB   = 0x08D
PIE1    = 0x091
OPTION_REG = 0x095
OSCCON  = 0x099
LATA    = 0x10C
LATB    = 0x10D
ANSELA  = 0x18C
ANSELB  = 0x18D
RCREG   = 0x199
TXREG   = 0x19A
SPBRGL  = 0x19B
SPBRGH  = 0x19C
RCSTA   = 0x19D
TXSTA   = 0x19E
BAUDCON = 0x19F
WPUA    = 0x20C
WPUB    = 0x20D
IOCBP   = 0x394
IOCBN   = 0x395


; PIC16F1847 Configuration Bit Settings
#include "p16F1847.inc"

;config bits: internal osc.

; CONFIG1
; __config 0xEFC4
 __CONFIG _CONFIG1, _FOSC_INTOSC & _WDTE_OFF & _PWRTE_ON & _MCLRE_ON & _CP_OFF & _CPD_OFF & _BOREN_ON & _CLKOUTEN_OFF & _IESO_OFF & _FCMEN_ON
; CONFIG2
; __config 0xDFFF
 __CONFIG _CONFIG2, _WRT_OFF & _PLLEN_ON & _STVREN_ON & _BORV_LO & _LVP_OFF


ml_temp          = 0x70
ml_count         = 0x71     ; used to count while clocking out
ml_bitcount      = 0x72     ; used to count while clocking out
ml_in16bitL      = 0x73
ml_in16bitH      = 0x74
ml_countSequence = 0x75     ; used to count the match-sequence terminating the serial input.
ml_timeCount     = 0x76
ml_nextCount     = 0x77     ; value to match against ml_timeCount for next output.
ml_ledSequenceCount = 0x78
;ml_byte0         = 0x79
;ml_byte1         = 0x7A
;ml_byte0flag     = 0x7B
ml_txCount       = 0x7C

DELAY_AFTER_RX  = 0x0A ; 0x32


portA_pin = 2
portB_led   = 0
portB_RX = 2
portB_baudsel = 3
portB_TX = 5
portB_powerJmp = 6


buffer = 0x2000  ; max size 1008 bytes (all bank-mem) Beginning must be multiple of 0x100
bufferEnd = 0x2300  ; End. Must be multiple of 6 bytes. And of 256... because of buffer-end-check for serial input.


	org 0
	goto skipToSetup

	org 4
	retfie

skipToSetup:
	; oscillator setup ..... To get 32MHz internal, FOSC=100 (INTOSC), SCS=00 (source=INTOSC), IRCF=1110 (8MHz), SPLLEN=1 (PLLEN)
	movlw 0xF0	; PLL on, int osc 8MHz, clockselect by config.
	banksel OSCCON
	movwf OSCCON
	banksel 0

	movlw 0xC8
pauseOsc:
	nop
	nop
	decfsz WREG,0
	bra pauseOsc

    ; clear buffer
	movlw low bufferEnd
	movwf FSR0L
	movlw high bufferEnd
	movwf FSR0H
clrlop:
	movlw 0
	movwi --FSR0
	movwi --FSR0
	movwi --FSR0
	movf FSR0L,0
	btfss STATUS,Z
	bra clrlop
	movf FSR0H,0
	xorlw high buffer
	btfss STATUS,Z
	bra clrlop



	; port setup
	banksel ANSELA
	clrf ANSELA
	clrf ANSELB
	banksel WPUA
	movlw 0xFF
	movwf WPUA
	movwf WPUB
	banksel LATA
	bcf LATA,portA_pin
	bcf LATB,portB_led
	banksel TRISA
	movlw 0xFF-(1<<portA_pin)
	movwf TRISA
	movlw 0xFF-(1<<portB_TX)
	movwf TRISB
	banksel OPTION_REG
	bcf OPTION_REG,7	; enable pull-ups with WPUx
	banksel 0


	; UART pin setup
	banksel APFCON0
	bsf APFCON1,0		; TXCKSEL: move UART TX to B5
	bsf APFCON0,7		; RXDTSEL: move UART RX to B2

	; UART BAUD rate setup. First set up for 250k.
	; formula for baudrate value:
	;  32e6/(16*250000)-1
	; 250kBaud @ 32MHz: 7
	banksel BAUDCON
	movlw 0x40
	movwf BAUDCON		; RCIDL (BRG16=0)
	banksel TXSTA
	bsf TXSTA,2 ; BRGH
	banksel SPBRGL
	movlw 0x07
	movwf SPBRGL
	movlw 0x00
	movwf SPBRGH
	banksel 0
	; check baudsel pin
	;btfsc PORTB,portB_baudselH
	;bra baudDone
lowSpeed:
	; low-speeds. set BRG16 bit to get moreprecision with these odd clock rates
	banksel BAUDCON
	bsf BAUDCON,3		; BRG16
	; and set to 115.2 kBaud.
	banksel SPBRGL
	movlw 0x44
	movwf SPBRGL
	banksel PORTB
	btfsc PORTB,portB_baudsel
	bra baudDone
	; set to 57.6 kBaud.
	banksel SPBRGL
	movlw 0x8A
	movwf SPBRGL
baudDone:

	; UART setup (no interrupts!)
	banksel TXSTA
	bcf TXSTA,4	; SYNC
	bsf TXSTA,5	; TXEN (go)
	banksel RCSTA
	bsf RCSTA,7	; SPEN

	; UART RX setup.
	banksel RCSTA
	bcf RCSTA,6 ; RX9
	bcf RCSTA,3 ; ADDEN
	bsf RCSTA,4 ; CREN (go!)
	banksel PIE1
	bcf PIE1,5	; without intrr

	; timer2 is the time-clock. always running without ints.  64*10*250=160000 -> 50 Hz (@8MHz).
	; value is polled from mainloop. It wraps slow enough for this.
	; timer 2 period is 160000 cycles.
	banksel TMR2
	movlw 0xF9	; 250-1
	movwf PR2
	movlw 0x4F  ; prescale=64, enable, postscale=1:10
	movwf T2CON
	clrf ml_timeCount
	banksel PIE1
	bcf PIE1,1  ; disable int


	clrf ml_nextCount

	clrf ml_ledSequenceCount

	clrf ml_txCount

	banksel 0
	movlw low buffer
	movwf FSR1L
	movlw high buffer
	movwf FSR1H



	; just testing for simulator.
;	movlw low buffer
;	movwf FSR1L
;	movlw high buffer
;	movwf FSR1H
;	movlw '#'
;	movwi FSR1++
;	movlw '#'
;	movwi FSR1++
;	call checkSeqF1
;	movlw 'S'
;	movwi FSR1++
;	movlw 'E'
;	movwi FSR1++
;	movlw 'Q'
;	movwi FSR1++
;	movlw '-'
;	movwi FSR1++
;	movlw 'E'
;	movwi FSR1++
;	movlw 'N'
;	movwi FSR1++
;	movlw 'D'
;	movwi FSR1++
;	call checkSeqF1
;	movlw '.'
;	movwi FSR1++
;	call checkSeqF1


	banksel 0
	movlw low buffer
	movwf FSR1L
	movlw high buffer
	movwf FSR1H

	goto begin



sendAll:
	banksel 0
	movlw low buffer
	movwf FSR0L
	movlw high buffer
	movwf FSR0H

	; check timer before
	btfss PIR1,1    ; TMR2 int flag?
	bra noTmr2_1
	bcf PIR1,1
	incf ml_timeCount,1
noTmr2_1:
	movlw 0xF0  ;;;   number of LEDs
	movwf ml_count
	banksel LATA

LEDloop:
	; get value from buffer
	banksel 0
	moviw FSR0++
	movwf ml_in16bitH
	moviw FSR0++
	movwf ml_in16bitL
	; extract high part
	lsrf ml_in16bitH,0
	lsrf WREG,0
	call gamma5
	; G-value in W-Reg
	banksel LATA
	clrf ml_bitcount
loopG:
	bsf LATA,portA_pin		; clk
	nop
	btfss WREG,7
	bcf LATA,portA_pin
	lslf WREG,1
	bcf LATA,portA_pin
	incf ml_bitcount,1
	btfss ml_bitcount,3
	bra loopG

	banksel 0
	btfss PIR1,1    ; TMR2 int flag?
	bra $+4
	bcf PIR1,1
	incf ml_timeCount,1
	decf ml_nextCount,1

	; get value from mid
	lslf ml_in16bitL,0
	movwf ml_temp
	rlf ml_in16bitH,0
	lslf ml_temp,1
	rlf WREG,0
	lslf ml_temp,1
	rlf WREG,0
	call gamma5
	; R-value in W-Reg
	banksel LATA
	clrf ml_bitcount
loopR:
	bsf LATA,portA_pin		; clk +15 or +17
	nop
	btfss WREG,7
	bcf LATA,portA_pin
	lslf WREG,1
	bcf LATA,portA_pin
	incf ml_bitcount,1
	btfss ml_bitcount,3
	bra loopR

	; test RX
	banksel PIR1
	btfss PIR1,5 ; RCIF
	bra noRXinLoop
	banksel RCREG
	movf RCREG,0
	movwi FSR1++
noRXinLoop:

	; get B-value from low
	movf ml_in16bitL,0
	call gamma5
	; B-value in W-Reg
	banksel LATA
	clrf ml_bitcount
loopB:
	bsf LATA,portA_pin		; clk +13 or +15
	nop
	btfss WREG,7
	bcf LATA,portA_pin
	lslf WREG,1
	bcf LATA,portA_pin
	incf ml_bitcount,1
	btfss ml_bitcount,3
	bra loopB
	; done
	movf ml_in16bitL,0
	; loop
	banksel 0
	decfsz ml_count,1
	bra LEDloop

	; reset ml_nextCount
	movlw 3
	movwf ml_nextCount

;	movlw low buffer
;	xorwf FSR1L,0
;	btfss STATUS,Z
;	bra hadquickRX
;	movlw high buffer
;	xorwf FSR1H,0
;	btfss STATUS,Z
;	bra hadquickRX
;	bra noquickRX
;hadquickRX:
	movlw DELAY_AFTER_RX
	movwf ml_nextCount
;noquickRX:



	; LED data stream is done. Keep receiving until having 192 bytes.
	; At this point, the input cannot have done the 192 bytes already.
	; keep receiving and wait for terminator sequence.
begin:
	banksel 0
	clrf ml_countSequence

waitrest:
	banksel 0
	btfss PIR1,1    ; TMR2 int flag?
	bra $+4
	bcf PIR1,1
	incf ml_timeCount,1
	decf ml_nextCount,1
	movlw 0x32
	subwf ml_timeCount,0
	btfsc STATUS,C
	movwf ml_timeCount

	banksel TRISB
	movlw 0x19
	subwf ml_timeCount,0
	btfsc STATUS,C
	bra $+3
	bsf TRISB,portB_led
	bra $+2
	bcf TRISB,portB_led
	banksel 0

	; check timeout?
;	btfsc ml_nextCount,7
;	bra timeOutWaitRX

	nop
	; check for UART output
	btfss PIR1,4	; TXIF
	bra noTX
	btfsc ml_txCount,6
	bra noTX
	movlw high getTXgreetMsgByte
	movwf PCLATH
	movf ml_txCount,0
	call getTXgreetMsgByte
	clrf PCLATH
	banksel TXREG
	movwf TXREG
	banksel 0
	incf ml_txCount,1
noTX:

	; check for UART input.

	banksel RCSTA
	btfss RCSTA,1		; OERR
	bra noOERR
	bcf RCSTA,1		; OERR
	bcf RCSTA,4		; CREN
	nop
	nop
	bsf RCSTA,4		; CREN
noOERR:


	banksel 0
	btfss PIR1,5	; RCIF
	bra waitrest
	; have a byte in the UART's input buffer.
	; first check timeout.

	movlw DELAY_AFTER_RX
	movwf ml_nextCount

	; now get the byte from UART RX.
	banksel RCREG
	movf RCREG,0
	banksel 0
	movwi FSR1++	; check buffer overrun?


	; check buffer pointer
	movlw low bufferEnd
	subwf FSR1L,0
	movlw high bufferEnd
	subwfb FSR1H,0
	btfsc STATUS,C
	moviw --FSR1	; decrease to stay at end. (this will break end-seq)
	; check received byte
	call checkSeqF1
	movwf ml_temp
	addlw '0'
	movf ml_temp,0
	btfss STATUS,Z
	bra waitrest
	; sequence is there.

	movlw 8	; overwrite sequence with 0.
	subwf FSR1L,1
	movlw 0
	subwfb FSR1H,1
	movwi FSR1++
	movwi FSR1++
	movwi FSR1++
	movwi FSR1++
	movwi FSR1++
	movwi FSR1++
	movwi FSR1++
	movwi FSR1++
	; send ack.
;	banksel TXREG
;	movlw 'A'
;	movwf TXREG	; this triggers UART hardware. Not waiting for completion.

	; reset receiveing pointer
	banksel 0
	movlw low buffer
	movwf FSR1L
	movlw high buffer
	movwf FSR1H

	; and go!
	goto sendAll

timeOutWaitRX:
	; timed out. do something here ourselves.
	; Move up all data.
	banksel 0
	movlw low bufferEnd
	movwf FSR1L
	movlw high bufferEnd
	movwf FSR1H
	movlw low (bufferEnd-2)
	movwf FSR0L
	movlw high (bufferEnd-2)
	movwf FSR0H
copyLoop:
	moviw --FSR0
	movwi --FSR1
	moviw --FSR0
	movwi --FSR1
	movf FSR0L,0
	btfss STATUS,Z
	bra copyLoop
	movf FSR0H,0
	xorlw high buffer
	btfss STATUS,Z
	bra copyLoop
	; done with move.

	; reset receiveing pointer
	banksel 0
	movlw low buffer
	movwf FSR1L
	movlw high buffer
	movwf FSR1H

	; insert new stuff.
	movf ml_ledSequenceCount,0
	movwf ml_temp
	clrf ml_in16bitL
	clrf ml_in16bitH
	movlw high sequenceR
	movwf PCLATH
	movf ml_temp,0
	call sequenceR
	andlw 0xF8
	movwf ml_in16bitH
	movf ml_temp,0
	call sequenceB
	lsrf WREG,0
	lsrf WREG,0
	lsrf WREG,0
	movwf ml_in16bitL
	movf ml_temp,0
	call sequenceG
	movwf ml_temp
	lsrf WREG,0
	lsrf WREG,0
	lsrf WREG,0
	lsrf WREG,0
	lsrf WREG,0
	iorwf ml_in16bitH,1
	lslf ml_temp,0
	lslf WREG,0
	lslf WREG,0
	andlw 0xE0
	iorwf ml_in16bitL,1
	clrf PCLATH
	movf ml_in16bitL,0
	movwf 0x21
	movf ml_in16bitH,0
	movwf 0x20

	; reduce power!
;	lsrf 0x20,1
;	lsrf 0x21,1
;	movlw 0x7B
;	andwf 0x20
;	movlw 0xEF
;	andwf 0x21


	banksel 0


    incf ml_ledSequenceCount,1

	;banksel TXREG
	;movlw '.'
	;movwf TXREG	; this triggers hardware. Not waiting for completion.
    ; and go!
    goto sendAll




checkSeqF1:
	; check the end-sequence "SEQ-END."
	; returns 0 if match.
	movlw low (buffer+8)
	subwf FSR1L,0
	movlw high (buffer+8)
	subwfb FSR1H,0
	btfss STATUS,C
	retlw 1	; too short
	movlw 8
	subwf FSR1L,1
	movlw 0
	subwfb FSR1H,1
	moviw FSR1++
	xorlw 'S'
	movwf ml_temp
	moviw FSR1++
	xorlw 'E'
	iorwf ml_temp,1
	moviw FSR1++
	xorlw 'Q'
	iorwf ml_temp,1
	moviw FSR1++
	xorlw '-'
	iorwf ml_temp,1
	moviw FSR1++
	xorlw 'E'
	iorwf ml_temp,1
	moviw FSR1++
	xorlw 'N'
	iorwf ml_temp,1
	moviw FSR1++
	xorlw 'D'
	iorwf ml_temp,1
	moviw FSR1++
	xorlw '.'
	iorwf ml_temp,1
	btfsc STATUS,Z
	retlw 0
	retlw 2



;#!/usr/bin/python
;import math
;vals=list();gamma=1.95;num=64
;for i in xrange(num):
; vals.append( max( int(255.0*math.pow(i/float(num-1),gamma)+0.5) , i ) )
;
;for i in xrange(0,num,16):
; print 'dw '+','.join("0x34%02X"%b for b in vals[i:i+16])
gamma5:
	; max 7
	andlw 0x1F
	brw
	dw 0x3400,0x3401,0x3402,0x3403,0x3405,0x3407,0x340A,0x340E,0x3412,0x3417,0x341C,0x3422,0x3428,0x342F,0x3436,0x343E
	dw 0x3446,0x344F,0x3458,0x3462,0x346C,0x3477,0x3483,0x348E,0x349B,0x34A8,0x34B5,0x34C3,0x34D1,0x34E0,0x34EF,0x34FF
	retlw 0xFF

gamma6:
	; max 7
	andlw 0x3F
	brw
	dw 0x3400,0x3401,0x3402,0x3403,0x3404,0x3405,0x3406,0x3407,0x3408,0x3409,0x340A,0x340B,0x340C,0x340D,0x340E,0x3410
	dw 0x3412,0x3414,0x3416,0x3419,0x341B,0x341E,0x3421,0x3424,0x3427,0x342A,0x342D,0x3431,0x3434,0x3438,0x343C,0x3440
	dw 0x3444,0x3448,0x344D,0x3451,0x3456,0x345A,0x345F,0x3464,0x3469,0x346E,0x3474,0x3479,0x347F,0x3484,0x348A,0x3490
	dw 0x3496,0x349C,0x34A2,0x34A9,0x34AF,0x34B6,0x34BD,0x34C4,0x34CB,0x34D2,0x34D9,0x34E0,0x34E8,0x34EF,0x34F7,0x34FF
	retlw 0xFF



	org 0x800

getTXgreetMsgByte:
	andlw 0x3F
	brw
;	dw 0x3420,0x3420,0x3420,0x340A,0x344C,0x3445,0x3444,0x3420,0x3473,0x3474,0x3472,0x3469,0x3470,0x342E,0x340A,0x3453
;	dw 0x3465,0x346E,0x3464,0x3420,0x3431,0x3436,0x342D,0x3462,0x3469,0x3474,0x342C,0x3420,0x3462,0x3469,0x3467,0x342D
;	dw 0x3465,0x346E,0x3464,0x3469,0x3461,0x346E,0x3420,0x3435,0x343A,0x3436,0x343A,0x3435,0x3420,0x3452,0x3447,0x3442
;	dw 0x3420,0x3464,0x3461,0x3474,0x3461,0x3420,0x346F,0x346E,0x3420,0x3455,0x3441,0x3452,0x3454,0x342E,0x340A,0x340A

	dw 0x3420,0x340A,0x340D,0x344C,0x3445,0x3444,0x3420,0x3473,0x3474,0x3472,0x3469,0x3470,0x342E,0x340A,0x340D,0x3453
	dw 0x3465,0x346E,0x3464,0x3420,0x3431,0x3436,0x342D,0x3462,0x3469,0x3474,0x342C,0x3420,0x3462,0x3469,0x3467,0x342D
	dw 0x3465,0x346E,0x3464,0x3469,0x3461,0x346E,0x3420,0x3435,0x343A,0x3436,0x343A,0x3435,0x3420,0x3452,0x3447,0x3442
	dw 0x3420,0x3464,0x3461,0x3474,0x3461,0x3420,0x346F,0x346E,0x3420,0x3455,0x3441,0x3452,0x3454,0x342E,0x340A,0x340D
;msg = " \n\rLED strip.\n\rSend 16-bit, big-endian 5:6:5 RGB data on UART.\n\r"
;len(msg)
;print "dw "+",".join( "0x%X"%(0x3400+ord(b)) for b in msg )


sequenceR:
	brw
	dw 0x3431,0x341F,0x3418,0x341F,0x3431,0x344B,0x3469,0x348B,0x34B0,0x34D7,0x34FF,0x34D7,0x34B0,0x348B,0x3469,0x344B
	dw 0x3431,0x341C,0x340C,0x3403,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3401,0x3405,0x340B,0x3412,0x341C,0x3428,0x3435,0x3443,0x3452,0x3461,0x3452,0x3443,0x3435,0x3428,0x341C
	dw 0x3412,0x340E,0x3411,0x341D,0x3431,0x344B,0x3469,0x348B,0x34B0,0x34D7,0x34FF,0x34D7,0x34B0,0x348B,0x3469,0x344B
	dw 0x3431,0x341D,0x3410,0x340D,0x3411,0x341B,0x3426,0x3432,0x343F,0x344D,0x345C,0x344D,0x343F,0x3432,0x3426,0x341B
	dw 0x3411,0x340B,0x3409,0x340B,0x3412,0x341C,0x3427,0x3434,0x3442,0x3451,0x3460,0x3451,0x3442,0x3434,0x3427,0x341C
	dw 0x3412,0x340B,0x340B,0x340D,0x3416,0x3422,0x342F,0x343F,0x344F,0x3461,0x3473,0x3461,0x344F,0x343F,0x342F,0x3422
	dw 0x3416,0x340E,0x3410,0x3417,0x3427,0x343B,0x3453,0x346E,0x348C,0x34AB,0x34CA,0x34AB,0x348C,0x346E,0x3453,0x343B
	dw 0x3427,0x3417,0x340C,0x3408,0x340A,0x340F,0x3415,0x341C,0x3423,0x342B,0x3433,0x342B,0x3423,0x341C,0x3415,0x340F
	dw 0x340A,0x3406,0x3402,0x3401,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3403,0x340B,0x3419,0x342B,0x3442,0x345D,0x347C,0x349C,0x34BF,0x34E2,0x34BF,0x349C,0x347C,0x345D,0x3442
	dw 0x342B,0x341B,0x3413,0x3416,0x3421,0x3433,0x3447,0x345E,0x3477,0x3492,0x34AD,0x3492,0x3477,0x345E,0x3447,0x3433
	dw 0x3421,0x3413,0x3408,0x3402,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3402,0x3407,0x340F,0x341B,0x3429,0x343A,0x344C,0x3461,0x3476,0x348C,0x3476,0x3461,0x344C,0x343A,0x3429
	dw 0x341B,0x3412,0x3413,0x341E,0x3431,0x344B,0x3469,0x348B,0x34B0,0x34D7,0x34FF,0x34D7,0x34B0,0x348B,0x3469,0x344B
	dw 0x3431,0x341F,0x3418,0x341F,0x3431,0x344B,0x3469,0x348B,0x34B0,0x34D7,0x34FE,0x34D7,0x34B0,0x348B,0x3469,0x344B

sequenceG:
	brw
	dw 0x3407,0x3407,0x340E,0x341C,0x3431,0x344B,0x3469,0x348B,0x34B0,0x34D7,0x34FF,0x34D7,0x34B0,0x348B,0x3469,0x344B
	dw 0x3431,0x341E,0x3414,0x3414,0x341E,0x342D,0x3440,0x3455,0x346B,0x3483,0x349B,0x3483,0x346B,0x3455,0x3440,0x342D
	dw 0x341E,0x3411,0x3408,0x3402,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3400,0x3401,0x3403,0x3404,0x3407,0x340A,0x340D,0x3410,0x3414,0x3417,0x3414,0x3410,0x340D,0x340A,0x3407
	dw 0x3404,0x3405,0x340B,0x3416,0x3427,0x343B,0x3453,0x346E,0x348B,0x34AA,0x34CA,0x34AA,0x348B,0x346E,0x3453,0x343B
	dw 0x3427,0x3416,0x340A,0x3402,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3403,0x340C,0x341A,0x342E,0x3447,0x3464,0x3484,0x34A7,0x34CC,0x34F2,0x34CC,0x34A7,0x3484,0x3464,0x3447
	dw 0x342E,0x341B,0x3411,0x340E,0x3413,0x341E,0x342A,0x3437,0x3446,0x3455,0x3465,0x3455,0x3446,0x3437,0x342A,0x341E
	dw 0x3413,0x340B,0x3405,0x3401,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3401,0x3402,0x3405,0x3409,0x340E,0x3414,0x341B,0x3422,0x3429,0x3431,0x3429,0x3422,0x341B,0x3414,0x340E
	dw 0x3409,0x3407,0x3409,0x3412,0x341D,0x342D,0x343F,0x3454,0x346A,0x3481,0x3499,0x3481,0x346A,0x3454,0x343F,0x342D
	dw 0x341D,0x3411,0x3408,0x3405,0x3405,0x3408,0x340B,0x340E,0x3412,0x3416,0x341A,0x3416,0x3412,0x340E,0x340B,0x3408
	dw 0x3405,0x3403,0x3403,0x3404,0x3407,0x340B,0x3410,0x3415,0x341B,0x3421,0x3427,0x3421,0x341B,0x3415,0x3410,0x340B

sequenceB:
	brw
	dw 0x3400,0x3403,0x340C,0x341C,0x3431,0x344B,0x3469,0x348B,0x34B0,0x34D7,0x34FF,0x34D7,0x34B0,0x348B,0x3469,0x344B
	dw 0x3431,0x341E,0x3413,0x3412,0x341A,0x3429,0x3439,0x344C,0x3460,0x3475,0x348A,0x3475,0x3460,0x344C,0x3439,0x3429
	dw 0x341A,0x3411,0x3411,0x3417,0x3426,0x343A,0x3451,0x346B,0x3488,0x34A6,0x34C5,0x34A6,0x3488,0x346B,0x3451,0x343A
	dw 0x3426,0x3415,0x340A,0x3402,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3402,0x340A,0x3416,0x3426,0x343A,0x3451,0x346C,0x3489,0x34A7,0x34C6,0x34A7,0x3489,0x346C,0x3451,0x343A
	dw 0x3426,0x3418,0x3413,0x3415,0x3422,0x3434,0x344A,0x3462,0x347B,0x3497,0x34B3,0x3497,0x347B,0x3462,0x344A,0x3434
	dw 0x3422,0x3414,0x340D,0x340C,0x3411,0x341B,0x3425,0x3432,0x343F,0x344D,0x345B,0x344D,0x343F,0x3432,0x3425,0x341B
	dw 0x3411,0x340A,0x3404,0x3401,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3402,0x3409,0x3415,0x3425,0x3438,0x344F,0x3469,0x3485,0x34A2,0x34C0,0x34A2,0x3485,0x3469,0x344F,0x3438
	dw 0x3425,0x3416,0x340C,0x3409,0x340D,0x3414,0x341C,0x3424,0x342E,0x3438,0x3443,0x3438,0x342E,0x3424,0x341C,0x3414
	dw 0x340D,0x3408,0x3409,0x340E,0x3417,0x3423,0x3432,0x3442,0x3453,0x3466,0x3478,0x3466,0x3453,0x3442,0x3432,0x3423
	dw 0x3417,0x3410,0x3412,0x341C,0x342F,0x3448,0x3465,0x3485,0x34A9,0x34CE,0x34F4,0x34CE,0x34A9,0x3485,0x3465,0x3448
	dw 0x342F,0x341B,0x340C,0x3403,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400
	dw 0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400,0x3400




    end


