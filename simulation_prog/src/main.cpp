#include <stdio.h>
#ifdef WIN32
#include "SDL.h"
#else
#include "SDL2/SDL.h"
#endif
#include <math.h>
#include "hexfield.h"
#include "UDPrecv.h"
#include "catch_ctrlC.h"
#include "commands.h"
#include "fix_values.h"

#undef main

// Raster eines Hex, mit waagerechter Zeile
// Abstand dx: 1.0    Abstand zwei Reihen dy: sin(60) = 0.5*sqrt(3) = 0.8660254037844386
/*
import math
q=math.sin(math.pi/3.0)
for i in xrange(256):
 print "%3u   %.2f" % (i,i*q)
*/

#define GLASSES_FIRST_ROW 14
#define GLASSES_HIGH 14

//#define STEP_X 37
//#define STEP_Y 32
//#define WINDOW_GFX_WIDTH 1056
//#define WINDOW_GFX_HEIGHT 950

#define STEP_X 27
#define STEP_Y 23
#define WINDOW_GFX_WIDTH (2*STEP_X*GLASSES_FIRST_ROW+8)
#define WINDOW_GFX_HEIGHT (2*STEP_Y*GLASSES_HIGH+30)

#define HEX_TEX_SIZE 128

/*
#!/usr/bin/python
import math
vals=list();gamma=1.0/1.95;num=1024
for i in xrange(num):
 vals.append( max( int(255.0*math.pow(i/float(num-1),gamma)+0.5) , 0 ) )

for i in xrange(0,num,32):
 print ' '+','.join("0x%02X"%b for b in vals[i:i+32])

*/
const unsigned short inverse_gamma195[] = {
	0x00,0x07,0x0A,0x0D,0x0F,0x11,0x12,0x14,0x15,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x24,0x25,0x26,0x27,0x28,0x28,0x29,0x2A,0x2A,
	0x2B,0x2C,0x2D,0x2D,0x2E,0x2E,0x2F,0x30,0x30,0x31,0x32,0x32,0x33,0x33,0x34,0x35,0x35,0x36,0x36,0x37,0x37,0x38,0x38,0x39,0x39,0x3A,0x3B,0x3B,0x3C,0x3C,0x3D,0x3D,
	0x3E,0x3E,0x3F,0x3F,0x3F,0x40,0x40,0x41,0x41,0x42,0x42,0x43,0x43,0x44,0x44,0x45,0x45,0x45,0x46,0x46,0x47,0x47,0x48,0x48,0x48,0x49,0x49,0x4A,0x4A,0x4B,0x4B,0x4B,
	0x4C,0x4C,0x4D,0x4D,0x4D,0x4E,0x4E,0x4F,0x4F,0x4F,0x50,0x50,0x50,0x51,0x51,0x52,0x52,0x52,0x53,0x53,0x54,0x54,0x54,0x55,0x55,0x55,0x56,0x56,0x56,0x57,0x57,0x57,
	0x58,0x58,0x59,0x59,0x59,0x5A,0x5A,0x5A,0x5B,0x5B,0x5B,0x5C,0x5C,0x5C,0x5D,0x5D,0x5D,0x5E,0x5E,0x5E,0x5F,0x5F,0x5F,0x60,0x60,0x60,0x61,0x61,0x61,0x62,0x62,0x62,
	0x62,0x63,0x63,0x63,0x64,0x64,0x64,0x65,0x65,0x65,0x66,0x66,0x66,0x67,0x67,0x67,0x67,0x68,0x68,0x68,0x69,0x69,0x69,0x69,0x6A,0x6A,0x6A,0x6B,0x6B,0x6B,0x6C,0x6C,
	0x6C,0x6C,0x6D,0x6D,0x6D,0x6E,0x6E,0x6E,0x6E,0x6F,0x6F,0x6F,0x70,0x70,0x70,0x70,0x71,0x71,0x71,0x71,0x72,0x72,0x72,0x73,0x73,0x73,0x73,0x74,0x74,0x74,0x74,0x75,
	0x75,0x75,0x76,0x76,0x76,0x76,0x77,0x77,0x77,0x77,0x78,0x78,0x78,0x78,0x79,0x79,0x79,0x79,0x7A,0x7A,0x7A,0x7B,0x7B,0x7B,0x7B,0x7C,0x7C,0x7C,0x7C,0x7D,0x7D,0x7D,
	0x7D,0x7E,0x7E,0x7E,0x7E,0x7F,0x7F,0x7F,0x7F,0x80,0x80,0x80,0x80,0x81,0x81,0x81,0x81,0x82,0x82,0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x84,0x85,0x85,
	0x85,0x85,0x86,0x86,0x86,0x86,0x87,0x87,0x87,0x87,0x87,0x88,0x88,0x88,0x88,0x89,0x89,0x89,0x89,0x8A,0x8A,0x8A,0x8A,0x8A,0x8B,0x8B,0x8B,0x8B,0x8C,0x8C,0x8C,0x8C,
	0x8D,0x8D,0x8D,0x8D,0x8D,0x8E,0x8E,0x8E,0x8E,0x8F,0x8F,0x8F,0x8F,0x8F,0x90,0x90,0x90,0x90,0x91,0x91,0x91,0x91,0x91,0x92,0x92,0x92,0x92,0x92,0x93,0x93,0x93,0x93,
	0x94,0x94,0x94,0x94,0x94,0x95,0x95,0x95,0x95,0x95,0x96,0x96,0x96,0x96,0x97,0x97,0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x98,0x99,0x99,0x99,0x99,0x99,0x9A,0x9A,0x9A,
	0x9A,0x9A,0x9B,0x9B,0x9B,0x9B,0x9C,0x9C,0x9C,0x9C,0x9C,0x9D,0x9D,0x9D,0x9D,0x9D,0x9E,0x9E,0x9E,0x9E,0x9E,0x9F,0x9F,0x9F,0x9F,0x9F,0xA0,0xA0,0xA0,0xA0,0xA0,0xA1,
	0xA1,0xA1,0xA1,0xA1,0xA2,0xA2,0xA2,0xA2,0xA2,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA4,0xA4,0xA4,0xA4,0xA4,0xA5,0xA5,0xA5,0xA5,0xA5,0xA6,0xA6,0xA6,0xA6,0xA6,0xA7,0xA7,
	0xA7,0xA7,0xA7,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA9,0xA9,0xA9,0xA9,0xA9,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xAB,0xAB,0xAB,0xAB,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAD,0xAD,
	0xAD,0xAD,0xAD,0xAE,0xAE,0xAE,0xAE,0xAE,0xAE,0xAF,0xAF,0xAF,0xAF,0xAF,0xB0,0xB0,0xB0,0xB0,0xB0,0xB0,0xB1,0xB1,0xB1,0xB1,0xB1,0xB2,0xB2,0xB2,0xB2,0xB2,0xB2,0xB3,
	0xB3,0xB3,0xB3,0xB3,0xB4,0xB4,0xB4,0xB4,0xB4,0xB4,0xB5,0xB5,0xB5,0xB5,0xB5,0xB5,0xB6,0xB6,0xB6,0xB6,0xB6,0xB7,0xB7,0xB7,0xB7,0xB7,0xB7,0xB8,0xB8,0xB8,0xB8,0xB8,
	0xB8,0xB9,0xB9,0xB9,0xB9,0xB9,0xB9,0xBA,0xBA,0xBA,0xBA,0xBA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBC,0xBC,0xBC,0xBC,0xBC,0xBC,0xBD,0xBD,0xBD,0xBD,0xBD,0xBD,0xBE,0xBE,
	0xBE,0xBE,0xBE,0xBE,0xBF,0xBF,0xBF,0xBF,0xBF,0xBF,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC3,0xC3,0xC3,0xC3,
	0xC3,0xC3,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC8,0xC8,0xC8,0xC8,0xC8,0xC8,
	0xC8,0xC9,0xC9,0xC9,0xC9,0xC9,0xC9,0xCA,0xCA,0xCA,0xCA,0xCA,0xCA,0xCB,0xCB,0xCB,0xCB,0xCB,0xCB,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCD,0xCD,0xCD,0xCD,0xCD,0xCD,
	0xCE,0xCE,0xCE,0xCE,0xCE,0xCE,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xD0,0xD0,0xD0,0xD0,0xD0,0xD0,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD1,0xD2,0xD2,0xD2,0xD2,0xD2,0xD2,
	0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD3,0xD4,0xD4,0xD4,0xD4,0xD4,0xD4,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD5,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD6,0xD7,0xD7,0xD7,0xD7,0xD7,
	0xD7,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD8,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xD9,0xDA,0xDA,0xDA,0xDA,0xDA,0xDA,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDB,0xDC,0xDC,0xDC,0xDC,
	0xDC,0xDC,0xDC,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDE,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xDF,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE1,0xE1,
	0xE1,0xE1,0xE1,0xE1,0xE1,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE2,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE4,0xE5,0xE5,0xE5,0xE5,0xE5,0xE5,
	0xE5,0xE5,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE6,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE7,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE8,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xE9,0xEA,0xEA,
	0xEA,0xEA,0xEA,0xEA,0xEA,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEB,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xEC,0xED,0xED,0xED,0xED,0xED,0xED,0xED,0xEE,0xEE,0xEE,0xEE,0xEE,
	0xEE,0xEE,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xEF,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF1,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,0xF2,
	0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF5,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF6,0xF7,0xF7,
	0xF7,0xF7,0xF7,0xF7,0xF7,0xF7,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xF9,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFB,0xFB,0xFB,
	0xFB,0xFB,0xFB,0xFB,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF
};



HexArray field;

void process_UDP_data( unsigned char *input_buffer , unsigned int input_data );
void process_mouse_click(int sx,int sy);
void draw( SDL_Renderer *rend , unsigned int frameNo );
bool draw_a_reg_poly(SDL_Texture *tex, float r1, float r2);
bool draw_a_hex     (SDL_Texture *tex, float r1, float r2);
bool draw_a_triangle(SDL_Texture *tex, float r1, float r2,bool bPointup);
bool get_cell_screen_coord(unsigned int seq_idx,int *out_w,int *out_h,unsigned int *out_color);
void ctrl_c_func(void *ctx);

/// program main function
int main(int argc, char* argv[])
{
  int res;
  bool sdl_started;
  SDL_Window *wnd;
  SDL_Renderer *rend;
  const char *errtxt=0;
  unsigned char input_buffer[10240+4]; // +4 to allow to null-terminate commands-packets.
  unsigned int no_input_count;
  unsigned int frameNo;
  bool running;

	errtxt=0;
	wnd=0;
	rend=0;
	sdl_started=false;

	if(!UDP_setup())
	{
		errtxt="Cannot setup UDP listen socket";
		goto leave;
	}


	// for full setup
	field.setup_square( GLASSES_FIRST_ROW , GLASSES_HIGH , false , false , false , true );


	res = SDL_Init( SDL_INIT_TIMER | SDL_INIT_VIDEO | SDL_INIT_EVENTS );
	if(res!=0)
		{errtxt="error initializing SDL lib.";goto leave;}
	sdl_started=true;

	wnd = SDL_CreateWindow(
			"hexstack",
			SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,
			WINDOW_GFX_WIDTH,WINDOW_GFX_HEIGHT,
			SDL_WINDOW_RESIZABLE
	);
	if(!wnd)
		{errtxt="Error creating window";goto leave;}

	rend = SDL_CreateRenderer( wnd , -1 , SDL_RENDERER_TARGETTEXTURE );
	if(!rend)
		{errtxt="Cannot init SDL renderer";goto leave;}


	no_input_count=0;
	frameNo = 0;
	running = true;

	CtrlC_handler_hook(ctrl_c_func,&running);

	load_default_gammacurves();

	while(running)
	{
	  SDL_Event e;
	  unsigned int input_data;
		while( SDL_PollEvent( &e ) != 0 )
		{
			//User requests quit
			if( e.type == SDL_QUIT )
				{errtxt=0;goto leave;}
			if( e.type == SDL_MOUSEBUTTONDOWN )
				{process_mouse_click(e.button.x,e.button.y);}
		}
		if(UDP_wait( input_buffer , &input_data , 100 ))
		{
			input_buffer[input_data] = 0;
			process_UDP_data( input_buffer , input_data );
			no_input_count=0;
		}else{
			no_input_count++;
			if(!(no_input_count&15))
			{
			  unsigned int color = 0x111111ul;
			  unsigned int t,num;
			  unsigned char *wr;
				load_default_gammacurves();
				num = field.get_sequence_count();
				if(no_input_count&16)
					color = 0x888888ul;
				for(t=0,wr=input_buffer;t<num;t++)
				{
					unsigned int tcol = color;
					*(wr++) = (tcol)&255;
					*(wr++) = (tcol>>8)&255;
					*(wr++) = (tcol>>16)&255;
				}
				// use same processing as normal data for idle-blink.
				process_UDP_data( input_buffer , num*3 );
			}
		}
		draw(rend,frameNo);
		SDL_RenderPresent( rend );
		frameNo++;
	}



//	SDL_Delay(1000);


leave:
	printf("exit\n");

	CtrlC_handler_unhook();

	if(sdl_started)
		SDL_Quit();
	UDP_halt();
	return (errtxt?1:0);
}

/// This is called from mainloop whenever there is data from UDP reception. It is placed in the color-data of the field.
void process_UDP_data( unsigned char *input_buffer , unsigned int input_data )
{
  unsigned int i,numl;
/*
  char dummy[64+4];static char hx[]="0123456789abcdef";
	for(i=0;i<32&&i<input_data;i++)
		{dummy[i+i] = hx[input_buffer[i]>>4];dummy[i+i+1] = hx[input_buffer[i]&15];}
	dummy[i+i]=0;
	printf("packet   '%s'\n",dummy);
*/
	if( input_data>=16 && !memcmp(input_buffer,COMMAND_PCK_PREFIX,16) )
	{
		// is a command, not RGB data.
		process_command_packet((const char*)(input_buffer+16));
		return;
	}

	numl = input_data/3;
	if(numl<1)return;

	// filter/process values (gamma, channel swap, ...)
	correct_values(input_buffer,numl);

	// at this point, the 'real' server would send the data to the LED strip.
	// here, we simulate, undo the GB swaps, add color differences, 
	// and the fact that monitor RGB colors get a gamma curve in the monitor (so do inverse-gamma).
	for( i=0 ; i<numl ; i++ )
	{
	  unsigned int r,g,b;
	  char typ;
		// undo the color-swaps. we want RGB here.
		if( i>=fix_map_GBswap__size || fix_map_GBswap[i]!='b' )
		{
			// type 'a' is G-R-B
			g = *(input_buffer++);
			r = *(input_buffer++);
			b = *(input_buffer++);
		}else{
			// type 'b' is B-R-G
			b = *(input_buffer++);
			r = *(input_buffer++);
			g = *(input_buffer++);
		}

		// increase to 10 bit for less rounding errors for subsequent calculations.
		r = (r<<2)+(r>>6);
		g = (g<<2)+(g>>6);
		b = (b<<2)+(b>>6);

		// falsify to simulate wrong colors or the different LED types in the setup (flakey gray).
		typ = 'w';
		if( i<fix_map_4types__size )
			typ = fix_map_4types[i];
		switch(typ)
		{
		case 'b':
			r = (r*0xD0)>>8;
			g = (g*0xD0)>>8;
			break;
		case 'l':
			g = (g*0xD0)>>8;
			break;
		case 'g':
			b = (b*0xD0)>>8;
			break;
		}

		// now apply inverse-gamma, because we have light-linear values here,
		// but the graphics RGB values will get gamma adjusted in the monitor.
		r = inverse_gamma195[r];
		g = inverse_gamma195[g];
		b = inverse_gamma195[b];

		if(!field.set_sequence_color( i , (r)+(g<<8)+(b<<16) ))
			break;
	}
}

/// called on mouse click. Find nearest cell and display current color value.
void process_mouse_click(int sx,int sy)
{
  int best_dist;
  unsigned int best_color;
  unsigned int best_seq;
	best_dist=0x7FFFFFFF;
	best_color = 0;
	best_seq = ~0;
	for( unsigned int t=0 ; ; t++ )
	{
	  int x,y;
	  unsigned int col;
	  int dist;
		if(!get_cell_screen_coord(t,&x,&y,&col))
			break;
		x-=sx;y-=sy;
		dist = x*x+y*y;
		if( t==0 || dist<best_dist )
		{
			best_dist=dist;
			best_color=col;
			best_seq=t;
		}
	}
	if( best_seq != (unsigned int)(~0) )
	{
	  unsigned int r,g,b;
		r = (best_color)&0xFF;
		g = (best_color>>8)&0xFF;
		b = (best_color>>16)&0xFF;
		printf("  cell #%u   R=0x%02X G=0x%02X B=0x%02X \n",best_seq,r,g,b);
	}
}

/// called from mainloop to render the graphics.
void draw( SDL_Renderer *rend , unsigned int frameNo )
{
//  Sint16 px[8],py[8];
  static SDL_Texture *otex[2]={0,0};
  SDL_Rect rc;
	if(!otex[0])
	{
		otex[1] = SDL_CreateTexture( rend , SDL_PIXELFORMAT_RGBA8888 , SDL_TEXTUREACCESS_STREAMING , HEX_TEX_SIZE , HEX_TEX_SIZE );
		if(!otex[1])return;
		otex[0] = SDL_CreateTexture( rend , SDL_PIXELFORMAT_RGBA8888 , SDL_TEXTUREACCESS_STREAMING , HEX_TEX_SIZE , HEX_TEX_SIZE );
		if(!otex[0])return;
		if(!draw_a_triangle(otex[0],0.24f*(float)STEP_X,0.29f*(float)STEP_X,false))
			return;
		if(!draw_a_triangle(otex[1],0.24f*(float)STEP_X,0.29f*(float)STEP_X,true))
			return;
//		if(!draw_a_hex(otex[0],0.15f*(float)STEP_X,0.15f*(float)STEP_X))
//			return;
//		if(!draw_a_hex(otex[1],0.15f*(float)STEP_X,0.15f*(float)STEP_X))
//			return;
	}
	SDL_RenderSetScale( rend , 1.0f , 1.0f );	// set to windowSize/logicalSize

	SDL_SetRenderDrawColor( rend , 68 , 68 , 68 , 255 );
	SDL_RenderClear( rend );

	SDL_SetRenderDrawColor( rend , 200 , 200 , 200 , 255 );

//	SDL_Texture *orgTex = SDL_GetRenderTarget(rend);
//	SDL_SetRenderTarget( rend , otex );
//	SDL_SetRenderTarget( rend , orgTex );


	SDL_SetTextureBlendMode( otex[0] , SDL_BLENDMODE_BLEND );
	SDL_SetTextureBlendMode( otex[1] , SDL_BLENDMODE_BLEND );
	rc.w = HEX_TEX_SIZE;
	rc.h = HEX_TEX_SIZE;

	for( unsigned int t=0 ; ; t++ )
	{
	  int x,y;
	  unsigned int col;
		if(!get_cell_screen_coord(t,&x,&y,&col))
			break;
		rc.x = x-(HEX_TEX_SIZE>>1);
		rc.y = y-(HEX_TEX_SIZE>>1);
		SDL_SetTextureColorMod(otex[t&1],(col)&0xFF,(col>>8)&0xFF,(col>>16)&0xFF);
		SDL_RenderCopy( rend , otex[t&1] , 0 , &rc );
	}

//	SDL_RenderDrawLine( rend , 0,0 , (frameNo%30)*10,300 );

}

/// Draw a regular polygon pixel-wise to a texture for later blitting. Done only once.
bool draw_a_reg_poly(SDL_Texture *tex, float r1, float r2, int corners, float ang0)
{
  int w,h,acc;
  float vx[16],vy[16];
  Uint32 tForm;
  void *pix;
  int pitch;
  unsigned int mulbits,addbits;
  float mulfac;
	if( corners<3 || corners>16 )
		return false;
	SDL_QueryTexture( tex , &tForm , &acc , &w , &h );
	switch(tForm)
	{
	case SDL_PIXELFORMAT_ABGR4444:
	case SDL_PIXELFORMAT_ARGB4444:
		mulfac=15.0;mulbits=0x1000;addbits=0x0FFF;break;
	case SDL_PIXELFORMAT_RGBA4444:
	case SDL_PIXELFORMAT_BGRA4444:
		mulfac=15.0;mulbits=0x0001;addbits=0xFFF0;break;
	case SDL_PIXELFORMAT_ARGB8888:
	case SDL_PIXELFORMAT_ABGR8888:
		mulfac=255.0;mulbits=0x01000000;addbits=0x00FFFFFF;break;
	case SDL_PIXELFORMAT_RGBA8888:
	case SDL_PIXELFORMAT_BGRA8888:
		mulfac=255.0;mulbits=0x01;addbits=0xFFFFFF00;break;
	default:
		return false;
	}
	if(SDL_LockTexture(tex,0,&pix,&pitch))
		return false;

	for(unsigned int t=0;t<(unsigned int)corners;t++)
	{
	  float ang = (float)t/(float)corners + ang0;
		ang *= 3.14159265359f*2.0f;
		vx[t] = cosf(ang);
		vy[t] = sinf(ang);
	}

  float hw=0.5f*w;
  float hh=0.5f*h;
	for(unsigned int y=0;(int)y<h;y++)
	{
	  unsigned int *pp = (unsigned int*)pix;
	  float fy = y-hh;
		for(unsigned int x=0;(int)x<w;x++)
		{
		  float fx = x-hw;
		  float fout = 0.0f;
			for(unsigned int t=0;t<(unsigned int)corners;t++)
			{
			  float tmp = fx*vx[t]+fy*vy[t];
				if( tmp>fout )fout=tmp;
			}
			fout = 1.0f - (fout-r1)/(r2-r1);
			if(fout<0.0f)fout=0.0f;
			if(fout>1.0f)fout=1.0f;
		  int mul = (int)(fout*mulfac+0.5f);
			*(pp++) = mulbits*mul + addbits ;
		}
		pix = ((char*)pix)+pitch;
	}


	SDL_UnlockTexture(tex);
	return true;
}

/// Draw a single hex pixel-wise to a texture for later blitting. Done only once.
bool draw_a_hex(SDL_Texture *tex ,float r1 ,float r2)
{
	return draw_a_reg_poly(tex,r1,r2,6,0.0f);
}

bool draw_a_triangle(SDL_Texture *tex, float r1, float r2,bool bPointup)
{
	return draw_a_reg_poly(tex,r1,r2,3,(bPointup?0.0f:1.0f)/6.0f-2/12.0f);
}

/// call the get_sequence_item() function, but transform output coords to screen-pixel coords.
bool get_cell_screen_coord(unsigned int seq_idx,int *out_w,int *out_h,unsigned int *out_color)
{
  unsigned int col;
  float fw,fh;
  int w,h;
	// calc pos for hex-grid. do not yet consider 6-subdiv.
	if(!field.get_sequence_item(seq_idx,&fw,&fh,&col))
		return false;
	if( (seq_idx%6) == ((seq_idx/6)%6) )
		col = 0;
	// calc pos of middle of the hex.
	w = (int)( STEP_X + STEP_X*0.125f + fw*STEP_X );
	h = (int)( WINDOW_GFX_HEIGHT - STEP_Y - STEP_Y*0.25f - fh*STEP_Y );

	*out_w = w;
	*out_h = h;
	if(out_color)
		*out_color = col;
	return true;
}

/// handler which is called when user hits Ctrl-C. Just sets the boolean pointed to by context to false.
void ctrl_c_func(void *ctx)
{
  bool *runvar;
	runvar = (bool*)ctx;
	*runvar = false;
}
