#include "fix_values.h"
#include <string.h>

// mapping table for flipping blue- and green parts.
const char fix_map_GBswap[] = \
		"aaaaaababbaaaa" \
		"aabaababaaaaa" \
		"aabaaaabbaaaaa" \
		"aaaaaabaabbaa" \
		"bbbbabbabaaaaa" \
		"ababaaaababaa" \
		"babbbabaabbbaa" \
		"abbaaabbbbbab" \
		"baabaabaababaa" \
		"aabaabaababaa" \
		"aabaaaaaaaaaaa" \
		"abbbbaabaabbb" \
		"aabbbaaababbba" \
		"abbbaaabbbaaa" \
		"aaaaaaaaaaaaaa" \
		"aaaaaaaaaaaaa"
		;

unsigned int fix_map_GBswap__size = sizeof(fix_map_GBswap);

// mapping table for the four chroma variants the LEDs have.
// strangely enough, this does not correlate with the tp map.
const char fix_map_4types[] = \
		"gwgwwwbwlbwglw" \
		"lwblglgllgggw" \
		"glllgglbbgwgwg" \
		"wwwllgblglblw" \
		"blllwlbgllwlww" \
		"llllwlglbwbll" \
		"bllllgblwllbll" \
		"llllglblbllll" \
		"lwglwllwgbwlll" \
		"lwlgwlwgbwlll" \
		"lwlgwgwwggwglw" \
		"llllllwllglbl" \
		"wllbbggglllllg" \
		"gbbbgglbbllgg" \
		;

unsigned int fix_map_4types__size = sizeof(fix_map_GBswap);

/*
#!/usr/bin/python
import math
vals=list();gamma=1.95;num=256
for i in xrange(num):
 vals.append( max( int(255.0*math.pow(i/float(num-1),gamma)+0.5) , 0 ) )

for i in xrange(0,num,16):
 print ' '+','.join("0x%02X"%b for b in vals[i:i+16])
*/
const unsigned char gamma195[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,
	0x01,0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x03,0x03,0x04,0x04,0x04,
	0x04,0x05,0x05,0x05,0x06,0x06,0x06,0x07,0x07,0x07,0x08,0x08,0x08,0x09,0x09,0x09,
	0x0A,0x0A,0x0B,0x0B,0x0B,0x0C,0x0C,0x0D,0x0D,0x0E,0x0E,0x0F,0x0F,0x10,0x10,0x11,
	0x11,0x12,0x12,0x13,0x13,0x14,0x14,0x15,0x16,0x16,0x17,0x17,0x18,0x19,0x19,0x1A,
	0x1B,0x1B,0x1C,0x1D,0x1D,0x1E,0x1F,0x1F,0x20,0x21,0x21,0x22,0x23,0x24,0x24,0x25,
	0x26,0x27,0x28,0x28,0x29,0x2A,0x2B,0x2C,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x31,0x32,
	0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x3F,0x40,0x41,
	0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x53,
	0x54,0x55,0x56,0x57,0x58,0x59,0x5B,0x5C,0x5D,0x5E,0x5F,0x61,0x62,0x63,0x64,0x66,
	0x67,0x68,0x69,0x6B,0x6C,0x6D,0x6E,0x70,0x71,0x72,0x74,0x75,0x76,0x78,0x79,0x7A,
	0x7C,0x7D,0x7F,0x80,0x81,0x83,0x84,0x86,0x87,0x88,0x8A,0x8B,0x8D,0x8E,0x90,0x91,
	0x93,0x94,0x96,0x97,0x99,0x9A,0x9C,0x9D,0x9F,0xA0,0xA2,0xA3,0xA5,0xA7,0xA8,0xAA,
	0xAB,0xAD,0xAF,0xB0,0xB2,0xB4,0xB5,0xB7,0xB8,0xBA,0xBC,0xBE,0xBF,0xC1,0xC3,0xC4,
	0xC6,0xC8,0xCA,0xCB,0xCD,0xCF,0xD1,0xD2,0xD4,0xD6,0xD8,0xD9,0xDB,0xDD,0xDF,0xE1,
	0xE3,0xE4,0xE6,0xE8,0xEA,0xEC,0xEE,0xF0,0xF2,0xF3,0xF5,0xF7,0xF9,0xFB,0xFD,0xFF
};

char gamma4[NUM_GAMMA_CURVES][4][256];


unsigned char chr_2_gammano(char sym)
{
	switch(sym)
	{
	case 'w': return 1;
	case 'g': return 2;
	case 'b': return 3;
	default: return 0;
	}
}

void load_default_gammacurves()
{
  unsigned int i;
	for( i=0 ; i<NUM_GAMMA_CURVES ; i++ )
	{
		memcpy(gamma4[i][0],gamma195,256);
		memcpy(gamma4[i][1],gamma195,256);
		memcpy(gamma4[i][2],gamma195,256);
	}
}

void correct_values(unsigned char *buffer,unsigned int numleds)
{
  unsigned int i;
  char sym;
// DEBUG
//  time_t tm;
//	tm = time(0);
// end DEBUG
	for(i=0;i<numleds;i++)
	{
		unsigned char r,g,b;
		r=buffer[0];
		g=buffer[1];
		b=buffer[2];
		sym = 'w';
		if( i<sizeof(fix_map_4types) )sym = fix_map_4types[i];
		sym = chr_2_gammano(sym);
		r = gamma4[(unsigned char)sym][0][r];
		g = gamma4[(unsigned char)sym][1][g];
		b = gamma4[(unsigned char)sym][2][b];
// DEBUG
//	tm = time(0);
//	if( (tm&2) && i<sizeof(fix_map_4types) && fix_map_4types[i]=='l' )
//		b=0;
// end DEBUG
		// check mapping table to swap blue- and green-parts.
		if( i>=sizeof(fix_map_GBswap) || fix_map_GBswap[i]!='b' )
		{
			// type 'a' is G-R-B
			*(buffer++)=g;
			*(buffer++)=r;
			*(buffer++)=b;
		}else{
			// type 'b' is B-R-G
			*(buffer++)=b;
			*(buffer++)=r;
			*(buffer++)=g;
		}
	}
}

// limits values in-place in input buffer
void limit_power(unsigned char *vals,unsigned int num_leds,unsigned char avg_max_pwm)
{
  unsigned int sumC1,sumC2,sumC3;
  unsigned int pow,max;
  unsigned int fact;
  unsigned int i;
  unsigned char *p;
	// count sums
	sumC1=sumC2=sumC3=0;
	for( p=vals,i=0 ; i<num_leds ; i++ )
	{
		sumC1 += *(p++);
		sumC2 += *(p++);
		sumC3 += *(p++);
	}
	pow = sumC1+sumC2+sumC3;
	max = avg_max_pwm*3*num_leds;
	if( pow <= max )
		return;
	// is too high. need to throttle.
	// with 60*60 LEDs, and 3 parts, all 0xFF, value is still less than (1<<22).
	fact = (max<<8) / pow;
	// scale all.
	for( p=vals,i=0 ; i<num_leds ; i++ )
	{
		p[0] = (unsigned char)((fact*p[0])>>8);
		p[1] = (unsigned char)((fact*p[1])>>8);
		p[2] = (unsigned char)((fact*p[2])>>8);
		p += 3;
	}
}
